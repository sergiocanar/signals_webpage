<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="style_main.css">
    <script src="https://code.highcharts.com/highcharts.js"></script>
</head>

<body>
    <h1 id="title">ECG Visualization</h1>
    <h2 id="subtitle">Lab 4</h2>
    <figure>
        <img src="https://data.org/wp-content/uploads/2022/02/Universidad-de-los-Andes-975x377.png" 
             alt="Universidad de los Andes" style="width: 10%">
        <figcaption>Departamento de Ingenieria Biomedica</figcaption>
    </figure>

    <label for="value1">Frequency: </label>
    <input type="range" id="value1" min="0" max="100" value="0" step="1" oninput="updateValue(this.value)">
    <span id="value1Display">0 Hz</span>

    <div id="ecg-container" style="width: 100%; height: 400px;"></div>
    <div id="tachogram-container" style="width: 100%; height: 400px; margin-top: 20px;"></div>

    <script>
        function updateValue(val) {
            document.getElementById('value1Display').innerText = val + " Hz";
        }

        // Función para crear una señal artificial de ECG
        function createECG() {
            const width = 500;
            const height = 200;
            const amplitude = height / 2;
            const sampleRate = parseInt(document.getElementById('value1').value) || 10;
            const timePerSample = 1 / sampleRate;

            const maxAmplitude = amplitude * (0.5 + Math.random() * 0.5);
            const waveFrequency = 0.5 + Math.random() * 2;

            const time_array = [];
            const signal = [];

            for (let i = 0; i < width; i++) {
                let t = i * timePerSample;
                let y = maxAmplitude * Math.sin(2 * Math.PI * waveFrequency * t);
                time_array.push(t);
                signal.push(y);
            }

            return { time_array, signal };
        }

        // Función para detectar picos dentro de una ventana específica

        function detectPeaksInWindow(signal, start, end) {
            const peaks = [];
            const window = signal.slice(start, end); 
            const peakValues = window.filter((val, i) =>
                i > 0 && i < window.length - 1 && val > window[i - 1] && val > window[i + 1]
            );

            if (peakValues.length > 0) {
                const meanVal = mean(peakValues);
                const stdVal = std(peakValues, meanVal);

                const minThreshold = meanVal + 1 * stdVal;
                const maxThreshold = meanVal + 4 * stdVal;

                for (let i = 1; i < window.length - 1; i++) {
                    if (
                        window[i] >= minThreshold &&
                        window[i] <= maxThreshold &&
                        window[i] > window[i - 1] &&
                        window[i] > window[i + 1]
                    ) {
                        peaks.push(start + i);
                    }
                }
            }
            return peaks;
        }

        // Detección de picos con ventanas deslizantes
        function detectPeaksWithSlidingWindow(signal, windowSize, step) {
            const allPeaks = [];

            for (let start = 0; start < signal.length - windowSize; start += step) {
                const end = start + windowSize;
                const peaks = detectPeaksInWindow(signal, start, end);
                allPeaks.push(...peaks);
            }

            return allPeaks;
        }

        // Funciones auxiliares para calcular media y desviación estándar
        function mean(arr) {
            return arr.reduce((sum, value) => sum + value, 0) / arr.length;
        }

        function std(arr, meanVal) {
            const variance = arr.reduce((sum, value) => sum + Math.pow(value - meanVal, 2), 0) / arr.length;
            return Math.sqrt(variance);
        }


        // Calcular los RR-intervalos
        function calculateRRIntervals(peaks, time_array) {
            const rr_intervals = [];

            for (let i = 1; i < peaks.length; i++) {
                const rr = time_array[peaks[i]] - time_array[peaks[i - 1]];

                // No negativoso
                if (rr > 0) {
                    rr_intervals.push(rr);
                }
            }

            return rr_intervals;
        }

        // Función para graficar el ECG usando Highcharts
        function plotECG() {
            const data = createECG();
            const peaks = detectPeaksWithSlidingWindow(data.signal, 463, 10); // Usar ventanas de tamaño 463 y paso 10
            const rr_intervals = calculateRRIntervals(peaks, data.time_array);

            Highcharts.chart('ecg-container', {
                chart: { type: 'line' },
                title: { text: 'ECG Signal Plot' },
                xAxis: { title: { text: 'Time (seconds)' }, categories: data.time_array },
                yAxis: { title: { text: 'Amplitude' } },
                series: [{ name: 'ECG Signal', data: data.signal }]
            });

            plotTachogram(rr_intervals);
        }

        // Función para graficar el tachograma
        function plotTachogram(rr_intervals) {
            Highcharts.chart('tachogram-container', {
                chart: { type: 'line' },
                title: { text: 'Tachogram (RR Intervals)' },
                xAxis: { 
                    title: { text: 'Beat Number' },
                    min: 0,
                    allowDecimals: false
                },
                yAxis: { title: { text: 'RR Interval (seconds)' } },
                series: [{ 
                    name: 'RR Interval', 
                    data: rr_intervals.map((interval, index) => [index, interval]) // Usar el índice para el eje X
                }]
            });
        }

        // Re-graficar cada vez que se mueve el slider
        document.getElementById('value1').addEventListener('input', plotECG);

        // Actualizar ECG y tachograma cada 10 segundos
        setInterval(plotECG, 10000);

  
    </script>

    <footer id="footer">
        <p>Authors: Sergio Andres Canar Lozano (202020383) and David Tobon Molina (202123804)</p>
        <p>GitHub Profiles: <a href="https://github.com/sergiocanar">sergiocanar</a> and 
           <a href="https://github.com/DavidTobonIBIO">DavidTobonIBIO</a></p>
        <p>Source code: <a href="https://github.com/sergiocanar/singnals_webpage">
            https://github.com/sergiocanar/singnals_webpage</a></p>
    </footer>
</body>

</html>
